<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fun Learning Games for Kids</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useRef, useEffect } = React;
        
        const KidsLearningGame = () => {
          const [currentSection, setCurrentSection] = useState('menu');
          const [currentGame, setCurrentGame] = useState(null);

          const stories = [
            {
              id: 1,
              title: "The Happy Cat",
              lines: [
                "The cat is happy.",
                "She likes to play.",
                "She runs and jumps.",
                "She purrs all day."
              ]
            },
            {
              id: 2,
              title: "My Red Ball",
              lines: [
                "I have a red ball.",
                "It bounces high.",
                "I throw it up.",
                "It touches the sky."
              ]
            },
            {
              id: 3,
              title: "The Big Sun",
              lines: [
                "The sun is big.",
                "It is so bright.",
                "It makes me warm.",
                "It gives us light."
              ]
            }
          ];

          const coloringPages = [
            {
              id: 1,
              name: "Butterfly",
              svg: `<svg viewBox="0 0 200 200">
                <circle cx="100" cy="100" r="15" fill="black"/>
                <ellipse cx="70" cy="80" rx="35" ry="45" fill="white" stroke="black" stroke-width="2"/>
                <ellipse cx="130" cy="80" rx="35" ry="45" fill="white" stroke="black" stroke-width="2"/>
                <ellipse cx="70" cy="130" rx="35" ry="40" fill="white" stroke="black" stroke-width="2"/>
                <ellipse cx="130" cy="130" rx="35" ry="40" fill="white" stroke="black" stroke-width="2"/>
                <line x1="95" y1="90" x2="85" y2="70" stroke="black" stroke-width="2"/>
                <line x1="105" y1="90" x2="115" y2="70" stroke="black" stroke-width="2"/>
              </svg>`
            },
            {
              id: 2,
              name: "Fish",
              svg: `<svg viewBox="0 0 200 200">
                <ellipse cx="120" cy="100" rx="60" ry="35" fill="white" stroke="black" stroke-width="2"/>
                <circle cx="140" cy="95" r="5" fill="black"/>
                <path d="M 60 100 L 30 80 L 30 120 Z" fill="white" stroke="black" stroke-width="2"/>
                <path d="M 160 85 L 180 70 L 170 85 Z" fill="white" stroke="black" stroke-width="2"/>
                <path d="M 160 115 L 180 130 L 170 115 Z" fill="white" stroke="black" stroke-width="2"/>
              </svg>`
            },
            {
              id: 3,
              name: "Flower",
              svg: `<svg viewBox="0 0 200 200">
                <circle cx="100" cy="80" r="12" fill="yellow" stroke="black" stroke-width="2"/>
                <circle cx="88" cy="68" r="15" fill="white" stroke="black" stroke-width="2"/>
                <circle cx="112" cy="68" r="15" fill="white" stroke="black" stroke-width="2"/>
                <circle cx="120" cy="85" r="15" fill="white" stroke="black" stroke-width="2"/>
                <circle cx="112" cy="102" r="15" fill="white" stroke="black" stroke-width="2"/>
                <circle cx="88" cy="102" r="15" fill="white" stroke="black" stroke-width="2"/>
                <circle cx="80" cy="85" r="15" fill="white" stroke="black" stroke-width="2"/>
                <rect x="95" y="95" width="10" height="60" fill="green" stroke="black" stroke-width="2"/>
                <ellipse cx="75" cy="120" rx="20" ry="12" fill="white" stroke="black" stroke-width="2"/>
                <ellipse cx="125" cy="130" rx="18" ry="10" fill="white" stroke="black" stroke-width="2"/>
              </svg>`
            }
          ];

          const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739', '#52B788'];

          const [selectedColor, setSelectedColor] = useState(colors[0]);
          const [currentStory, setCurrentStory] = useState(0);

          const MainMenu = () => (
            <div className="min-h-screen bg-gradient-to-br from-pink-200 via-purple-200 to-blue-200 p-8">
              <h1 className="text-5xl font-bold text-center mb-12 text-purple-800">
                ‚ú® Fun Learning Games ‚ú®
              </h1>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-8 max-w-6xl mx-auto">
                <button
                  onClick={() => setCurrentSection('brain')}
                  className="bg-gradient-to-br from-yellow-300 to-orange-400 p-12 rounded-3xl shadow-2xl hover:scale-105 transform transition"
                >
                  <div className="text-6xl mb-4">üß†</div>
                  <h2 className="text-3xl font-bold text-white">Brain Games</h2>
                </button>
                <button
                  onClick={() => setCurrentSection('reading')}
                  className="bg-gradient-to-br from-green-300 to-teal-400 p-12 rounded-3xl shadow-2xl hover:scale-105 transform transition"
                >
                  <div className="text-6xl mb-4">üìö</div>
                  <h2 className="text-3xl font-bold text-white">Reading</h2>
                </button>
                <button
                  onClick={() => setCurrentSection('coloring')}
                  className="bg-gradient-to-br from-pink-300 to-purple-400 p-12 rounded-3xl shadow-2xl hover:scale-105 transform transition"
                >
                  <div className="text-6xl mb-4">üé®</div>
                  <h2 className="text-3xl font-bold text-white">Coloring</h2>
                </button>
              </div>
            </div>
          );

          const BrainGamesMenu = () => (
            <div className="min-h-screen bg-gradient-to-br from-yellow-100 to-orange-200 p-8">
              <button
                onClick={() => setCurrentSection('menu')}
                className="mb-6 flex items-center gap-2 bg-white px-6 py-3 rounded-full shadow-lg hover:shadow-xl"
              >
                ‚Üê Back to Menu
              </button>
              <h1 className="text-5xl font-bold text-center mb-12 text-orange-800">Brain Games</h1>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-4xl mx-auto">
                <button
                  onClick={() => setCurrentGame('maze')}
                  className="bg-white p-10 rounded-3xl shadow-xl hover:scale-105 transform transition"
                >
                  <h3 className="text-3xl font-bold text-orange-600 mb-2">Simple Maze</h3>
                  <p className="text-gray-600 text-xl">Drag to find the path!</p>
                </button>
                <button
                  onClick={() => setCurrentGame('numbers')}
                  className="bg-white p-10 rounded-3xl shadow-xl hover:scale-105 transform transition"
                >
                  <h3 className="text-3xl font-bold text-orange-600 mb-2">Number Games</h3>
                  <p className="text-gray-600 text-xl">Learn numbers!</p>
                </button>
              </div>
            </div>
          );

          const SimpleMaze = () => {
            const [currentMazeLevel, setCurrentMazeLevel] = useState(0);
            const [isDrawing, setIsDrawing] = useState(false);
            const [drawnPath, setDrawnPath] = useState([]);
            const [won, setWon] = useState(false);
            const canvasRef = useRef(null);
            const [canvasSize, setCanvasSize] = useState({ width: 0, height: 0 });

            const mazes = [
              {
                level: 1,
                title: "Bee to Flower",
                character: 'üêù',
                target: 'üå∏',
                solution: [[0,0], [1,0], [2,0], [2,1], [2,2], [3,2], [3,3]],
                paths: [
                  {from: [0,0], to: [1,0]}, {from: [1,0], to: [2,0]},
                  {from: [2,0], to: [2,1]}, {from: [2,1], to: [2,2]},
                  {from: [2,2], to: [3,2]}, {from: [3,2], to: [3,3]},
                  {from: [0,0], to: [0,1]}, {from: [0,1], to: [0,2]},
                  {from: [1,0], to: [1,1]}
                ],
                size: 4
              },
              {
                level: 2,
                title: "Fish to Coral",
                character: 'üê†',
                target: 'ü™∏',
                solution: [[0,0], [1,0], [1,1], [1,2], [2,2], [3,2], [3,3], [4,3], [4,4]],
                paths: [
                  {from: [0,0], to: [1,0]}, {from: [1,0], to: [1,1]},
                  {from: [1,1], to: [1,2]}, {from: [1,2], to: [2,2]},
                  {from: [2,2], to: [3,2]}, {from: [3,2], to: [3,3]},
                  {from: [3,3], to: [4,3]}, {from: [4,3], to: [4,4]},
                  {from: [0,0], to: [0,1]}, {from: [2,2], to: [2,3]},
                  {from: [1,2], to: [0,2]}
                ],
                size: 5
              },
              {
                level: 3,
                title: "Bunny to Carrot",
                character: 'üê∞',
                target: 'ü•ï',
                solution: [[0,0], [0,1], [0,2], [1,2], [2,2], [3,2], [3,3], [3,4], [4,4]],
                paths: [
                  {from: [0,0], to: [0,1]}, {from: [0,1], to: [0,2]},
                  {from: [0,2], to: [1,2]}, {from: [1,2], to: [2,2]},
                  {from: [2,2], to: [3,2]}, {from: [3,2], to: [3,3]},
                  {from: [3,3], to: [3,4]}, {from: [3,4], to: [4,4]},
                  {from: [0,0], to: [1,0]}, {from: [1,0], to: [2,0]},
                  {from: [1,2], to: [1,3]}, {from: [2,2], to: [2,1]}
                ],
                size: 5
              },
              {
                level: 4,
                title: "Cat to Yarn",
                character: 'üê±',
                target: 'üß∂',
                solution: [[0,0], [1,0], [2,0], [2,1], [2,2], [2,3], [3,3], [4,3], [4,4]],
                paths: [
                  {from: [0,0], to: [1,0]}, {from: [1,0], to: [2,0]},
                  {from: [2,0], to: [2,1]}, {from: [2,1], to: [2,2]},
                  {from: [2,2], to: [2,3]}, {from: [2,3], to: [3,3]},
                  {from: [3,3], to: [4,3]}, {from: [4,3], to: [4,4]},
                  {from: [0,0], to: [0,1]}, {from: [1,0], to: [1,1]},
                  {from: [2,3], to: [1,3]}, {from: [3,3], to: [3,4]}
                ],
                size: 5
              },
              {
                level: 5,
                title: "Monkey to Banana",
                character: 'üêµ',
                target: 'üçå',
                solution: [[0,0], [0,1], [0,2], [1,2], [1,3], [2,3], [3,3], [4,3], [4,4], [5,4], [5,5]],
                paths: [
                  {from: [0,0], to: [0,1]}, {from: [0,1], to: [0,2]},
                  {from: [0,2], to: [1,2]}, {from: [1,2], to: [1,3]},
                  {from: [1,3], to: [2,3]}, {from: [2,3], to: [3,3]},
                  {from: [3,3], to: [4,3]}, {from: [4,3], to: [4,4]},
                  {from: [4,4], to: [5,4]}, {from: [5,4], to: [5,5]},
                  {from: [0,0], to: [1,0]}, {from: [1,2], to: [2,2]},
                  {from: [2,3], to: [2,4]}, {from: [4,3], to: [4,2]}
                ],
                size: 6
              }
            ];

            const currentMaze = mazes[currentMazeLevel];

            useEffect(() => {
              const updateCanvasSize = () => {
                const container = document.getElementById('maze-container');
                if (container) {
                  const size = Math.min(container.clientWidth, 600);
                  setCanvasSize({ width: size, height: size });
                }
              };
              updateCanvasSize();
              window.addEventListener('resize', updateCanvasSize);
              return () => window.removeEventListener('resize', updateCanvasSize);
            }, []);

            const getCanvasPos = (clientX, clientY) => {
              const canvas = canvasRef.current;
              if (!canvas) return null;
              
              const rect = canvas.getBoundingClientRect();
              const x = clientX - rect.left;
              const y = clientY - rect.top;
              
              return { x, y };
            };

            const getGridPos = (x, y) => {
              const cellSize = canvasSize.width / currentMaze.size;
              const gridX = Math.floor(x / cellSize);
              const gridY = Math.floor(y / cellSize);
              
              if (gridX >= 0 && gridX < currentMaze.size && gridY >= 0 && gridY < currentMaze.size) {
                return [gridX, gridY];
              }
              return null;
            };

            const isOnPath = (x, y) => {
              const cellSize = canvasSize.width / currentMaze.size;
              const threshold = cellSize * 0.4;
              
              for (let path of currentMaze.paths) {
                const x1 = path.from[0] * cellSize + cellSize / 2;
                const y1 = path.from[1] * cellSize + cellSize / 2;
                const x2 = path.to[0] * cellSize + cellSize / 2;
                const y2 = path.to[1] * cellSize + cellSize / 2;
                
                const dist = pointToLineDistance(x, y, x1, y1, x2, y2);
                if (dist < threshold) return true;
              }
              return false;
            };

            const pointToLineDistance = (px, py, x1, y1, x2, y2) => {
              const A = px - x1;
              const B = py - y1;
              const C = x2 - x1;
              const D = y2 - y1;
              
              const dot = A * C + B * D;
              const lenSq = C * C + D * D;
              let param = -1;
              
              if (lenSq !== 0) param = dot / lenSq;
              
              let xx, yy;
              
              if (param < 0) {
                xx = x1;
                yy = y1;
              } else if (param > 1) {
                xx = x2;
                yy = y2;
              } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
              }
              
              const dx = px - xx;
              const dy = py - yy;
              return Math.sqrt(dx * dx + dy * dy);
            };

            const handleStart = (clientX, clientY) => {
              const pos = getCanvasPos(clientX, clientY);
              if (!pos) return;
              
              const gridPos = getGridPos(pos.x, pos.y);
              if (gridPos && gridPos[0] === 0 && gridPos[1] === 0) {
                setIsDrawing(true);
                setDrawnPath([pos]);
              }
            };

            const handleMove = (clientX, clientY) => {
              if (!isDrawing) return;
              
              const pos = getCanvasPos(clientX, clientY);
              if (!pos) return;
              
              if (isOnPath(pos.x, pos.y)) {
                setDrawnPath(prev => [...prev, pos]);
              }
            };

            const handleEnd = () => {
              if (!isDrawing) return;
              setIsDrawing(false);
              
              if (drawnPath.length === 0) return;
              
              const lastPos = drawnPath[drawnPath.length - 1];
              const endGridPos = getGridPos(lastPos.x, lastPos.y);
              
              const targetPos = currentMaze.solution[currentMaze.solution.length - 1];
              if (endGridPos && endGridPos[0] === targetPos[0] && endGridPos[1] === targetPos[1]) {
                setWon(true);
              } else {
                setTimeout(() => setDrawnPath([]), 500);
              }
            };

            const nextLevel = () => {
              if (currentMazeLevel < mazes.length - 1) {
                setCurrentMazeLevel(currentMazeLevel + 1);
              } else {
                setCurrentMazeLevel(0);
              }
              setDrawnPath([]);
              setWon(false);
            };

            const reset = () => {
              setDrawnPath([]);
              setWon(false);
              setIsDrawing(false);
            };

            useEffect(() => {
              const canvas = canvasRef.current;
              if (!canvas || canvasSize.width === 0) return;
              
              const ctx = canvas.getContext('2d');
              ctx.clearRect(0, 0, canvasSize.width, canvasSize.height);
              
              const cellSize = canvasSize.width / currentMaze.size;
              
              // Draw paths
              ctx.strokeStyle = '#94a3b8';
              ctx.lineWidth = cellSize * 0.25;
              ctx.lineCap = 'round';
              
              currentMaze.paths.forEach(path => {
                ctx.beginPath();
                ctx.moveTo(path.from[0] * cellSize + cellSize / 2, path.from[1] * cellSize + cellSize / 2);
                ctx.lineTo(path.to[0] * cellSize + cellSize / 2, path.to[1] * cellSize + cellSize / 2);
                ctx.stroke();
              });
              
              // Draw user's path
              if (drawnPath.length > 1) {
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = cellSize * 0.2;
                ctx.beginPath();
                ctx.moveTo(drawnPath[0].x, drawnPath[0].y);
                drawnPath.forEach(point => {
                  ctx.lineTo(point.x, point.y);
                });
                ctx.stroke();
              }
            }, [drawnPath, canvasSize, currentMaze]);

            return (
              <div className="min-h-screen bg-gradient-to-br from-yellow-100 to-orange-200 p-4 md:p-8">
                <button onClick={() => setCurrentGame(null)} className="mb-4 flex items-center gap-2 bg-white px-4 py-2 rounded-full shadow-lg text-sm md:text-base">
                  ‚Üê Back
                </button>
                <h2 className="text-3xl md:text-4xl font-bold text-center mb-2 text-orange-800">{currentMaze.title}</h2>
                <p className="text-xl md:text-2xl text-center mb-2 text-orange-700">Level {currentMaze.level} of {mazes.length}</p>
                <p className="text-lg md:text-xl text-center mb-4 text-orange-600">Drag your finger from {currentMaze.character} to {currentMaze.target}!</p>
                
                <div className="max-w-3xl mx-auto bg-white p-4 md:p-8 rounded-3xl shadow-2xl">
                  <div id="maze-container" className="relative bg-white rounded-2xl" style={{ aspectRatio: '1/1', maxWidth: '600px', margin: '0 auto' }}>
                    <canvas
                      ref={canvasRef}
                      width={canvasSize.width}
                      height={canvasSize.height}
                      className="absolute inset-0 touch-none"
                      style={{ cursor: 'crosshair' }}
                      onMouseDown={(e) => handleStart(e.clientX, e.clientY)}
                      onMouseMove={(e) => handleMove(e.clientX, e.clientY)}
                      onMouseUp={handleEnd}
                      onMouseLeave={handleEnd}
                      onTouchStart={(e) => {
                        e.preventDefault();
                        const touch = e.touches[0];
                        handleStart(touch.clientX, touch.clientY);
                      }}
                      onTouchMove={(e) => {
                        e.preventDefault();
                        const touch = e.touches[0];
                        handleMove(touch.clientX, touch.clientY);
                      }}
                      onTouchEnd={(e) => {
                        e.preventDefault();
                        handleEnd();
                      }}
                    />
                    
                    {/* Emojis positioned on grid */}
                    <div className="absolute inset-0 pointer-events-none grid" style={{ gridTemplateColumns: `repeat(${currentMaze.size}, 1fr)` }}>
                      {Array.from({ length: currentMaze.size * currentMaze.size }).map((_, i) => {
                        const x = i % currentMaze.size;
                        const y = Math.floor(i / currentMaze.size);
                        const isStart = x === 0 && y === 0;
                        const isEnd = x === currentMaze.solution[currentMaze.solution.length - 1][0] && 
                                     y === currentMaze.solution[currentMaze.solution.length - 1][1];
                        
                        return (
                          <div key={i} className="flex items-center justify-center">
                            <div className="text-4xl md:text-5xl lg:text-6xl">
                              {isStart && currentMaze.character}
                              {isEnd && currentMaze.target}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                  
                  <div className="mt-6 text-center">
                    <button onClick={reset} className="bg-orange-500 text-white px-6 py-2 rounded-full text-lg hover:bg-orange-600">
                      Reset
                    </button>
                  </div>
                  
                  {won && (
                    <div className="mt-6 text-center">
                      <p className="text-3xl md:text-4xl font-bold text-green-600 mb-4">üéâ You Found It! üéâ</p>
                      <button onClick={nextLevel} className="bg-green-500 text-white px-8 py-4 rounded-full text-xl md:text-2xl hover:bg-green-600">
                        {currentMazeLevel < mazes.length - 1 ? 'Next Level ‚Üí' : 'Play Again from Level 1'}
                      </button>
                    </div>
                  )}
                </div>
              </div>
            );
          };

          const NumberGame = () => {
            const [gameType, setGameType] = useState(null);
            const [currentQuestion, setCurrentQuestion] = useState(0);
            const [score, setScore] = useState(0);
            const [selectedAnswers, setSelectedAnswers] = useState([]);
            const [showResult, setShowResult] = useState(false);
            const [isCorrect, setIsCorrect] = useState(false);

            const ascendingQuestions = [
              { numbers: [5, 2, 6], correct: [2, 5, 6] },
              { numbers: [3, 1, 4], correct: [1, 3, 4] },
              { numbers: [7, 9, 3], correct: [3, 7, 9] },
              { numbers: [6, 4, 8], correct: [4, 6, 8] },
              { numbers: [5, 7, 1], correct: [1, 5, 7] }
            ];

            const descendingQuestions = [
              { numbers: [5, 8, 3], correct: [8, 5, 3] },
              { numbers: [6, 9, 2], correct: [9, 6, 2] },
              { numbers: [4, 1, 7], correct: [7, 4, 1] },
              { numbers: [5, 3, 9], correct: [9, 5, 3] },
              { numbers: [6, 2, 8], correct: [8, 6, 2] }
            ];

            const betweenQuestions = [
              { numbers: [3, '?', 5], correct: 4, options: [2, 4, 6] },
              { numbers: [5, '?', 7], correct: 6, options: [4, 6, 8] },
              { numbers: [1, '?', 3], correct: 2, options: [1, 2, 4] },
              { numbers: [6, '?', 8], correct: 7, options: [5, 7, 9] },
              { numbers: [2, '?', 4], correct: 3, options: [1, 3, 5] }
            ];

            const afterQuestions = [
              { numbers: [4, '?', '?'], correct: 5, options: [3, 5, 6] },
              { numbers: [7, '?', '?'], correct: 8, options: [6, 8, 9] },
              { numbers: [2, '?', '?'], correct: 3, options: [1, 3, 4] },
              { numbers: [5, '?', '?'], correct: 6, options: [4, 6, 7] },
              { numbers: [8, '?', '?'], correct: 9, options: [7, 9, 10] }
            ];

            const beforeQuestions = [
              { numbers: ['?', '?', 5], correct: 4, options: [3, 4, 6] },
              { numbers: ['?', '?', 8], correct: 7, options: [6, 7, 9] },
              { numbers: ['?', '?', 3], correct: 2, options: [1, 2, 4] },
              { numbers: ['?', '?', 7], correct: 6, options: [5, 6, 8] },
              { numbers: ['?', '?', 9], correct: 8, options: [7, 8, 10] }
            ];

            const getQuestions = () => {
              if (gameType === 'ascending') return ascendingQuestions;
              if (gameType === 'descending') return descendingQuestions;
              if (gameType === 'between') return betweenQuestions;
              if (gameType === 'after') return afterQuestions;
              if (gameType === 'before') return beforeQuestions;
              return [];
            };

            const questions = getQuestions();
            const question = questions[currentQuestion];

            const handleNumberClick = (num) => {
              if (gameType === 'ascending' || gameType === 'descending') {
                if (selectedAnswers.includes(num)) return;
                
                const newAnswers = [...selectedAnswers, num];
                setSelectedAnswers(newAnswers);
                
                if (newAnswers.length === 3) {
                  const correct = JSON.stringify(newAnswers) === JSON.stringify(question.correct);
                  setIsCorrect(correct);
                  if (correct) setScore(score +
